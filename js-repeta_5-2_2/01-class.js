/*
 * Классы
 * 🐷 - объявление
 * 🐷 - конструктор
 * 🐷 - методы
 * 🐷 - static
 * 🐷 - приватные свойства
 * 🐷 - синтаксис публичных свойства и методы классов
 * 🐷 - геттеры и сеттеры
 */
// Классы - это новый способ записывать функцию-конструктор с уже готовым прототипом.
// Для объявления класса используется служебное слово "class" в начале синтоксической конструкции объявления функции-конструктора.

// Объявляем класс "Car1"
class Car1 { 
    // В начале любого тела класса сначала пишут перечень всех статических свойств и статических методов. В конце каждого статического свойства должен стоять знак - ";", а в конце кода статического метода (функции) - ";" или любой другой вспомогательный знак - НЕ ставится. После чего, при необходимости объявляются приватные свойства, в конце каждого из которых ставится ";". Далее, пишется код конструктора в теле - "constructor(){}" и методы, которые между собой не разделяются никакими дополнительными знаками.

    // Создаем статические свойства, которые доступны только классу. Для обозначения статического свойства используют служебное слово "static".
    // Статическое свойство с текстовым литералом
    static AAA = 'Cтатическое свойство класс "Car1.AAA"';

    // Статическое свойство - функция (метод)
    static logInfo(carObj) {
        console.log('статический метод класса "Car.logInfo => carObj" ->', carObj)
    }

    // Объявляем приватные свойства, используя для этого символ "#" в начале имени.
    #privetProperty = 'Test privet property';
    // Приватные свойства - являются передаваемой экземплярам и видимой в "тулзах" частью исходного кода класса (функции-конструктора). Однако, их вывов, изменение и другое оперирование через экземпляры - НЕ возможно. Они используются для записи неких констант, которые можно использовать в коде методов исходного класса (см. больше - https://learn.javascript.ru/private-protected-properties-methods).

    // Создаем публичные свойства класса вне "тела" конструктора классов "constructor() {}".
    mySuperPublicField = 555;
    // Является полным аналагом записи шаблонного свойства находящегося внутри тела конструктора классов, наследуемого экземпляром и доступного в нем из вне.

    // Публичное свойство в виде функционального выражения
    changePrice = (newPrice) => {
        this.price = newPrice;
    }
    // Важной особенностью публичных свойств является то, что копия каждого подобного свойства копируется в тело экземпляра. Именно поэтому - методы класса и функциональные выражения - НЕ делают публичными свойствами, а кодируют как свойства прототипа, которые доступны по ссылке.


    // Конструктор класса, определенный с помощью соответствующей синтаксической записи - "constructor() {}". В конструкторе класса создается шаблон того, что должно "пойти" на соответствующий экземпляр.
    constructor({brand, model, price} = {}) {
        // Тело конструктора выполняется автоматически при создании (объявлении) экземпляра соответствующего класса.
        console.log('Выполняется "constructor"');
        console.log(this);

        // Задаем набор шаблонных свойств для экземпляров, т.е. создаем публичные свойства
        this.brand = brand;
        this.model = model;
        this.price = price;

        // Выводим в лог значение приватного свойства "#privetProperty" изнутри метода класса
        console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
        console.log('"this.#privetProperty" =>', this.#privetProperty);
        console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
    }

    // За пределами "тела" конструктора классов пишется код того, что должно находится в свойствах "[[Prototype]]" создоваемых экземпляров, и должно быть доступно им по ссылке, например - методы. 

    // Создаем методы, которые будут доступны всем экземплярам по ссылке, через "[[Prototype]]"
    updateModel(newModel) {
        this.model = newModel;
    }

    // Важной особенностью синтаксической записи классов является то, что внутри тела класса, все методы между собой не нужно разделять дополнительными символами в виде ",", ";" или других. Они отделяются друг от друга только именем и "{}" их тела.
};
// Выводим объявленный класс "Car1" в консоль
console.dir(Car1);
console.log('--------------------------------------------');
// Выводим в лог статическое свойство класс "Car1" - "AAA"
console.dir(Car1.AAA);
console.log('--------------------------------------------');


// Создаем "экземпляр" на основе класса "Car1"
const carInstance1 = new Car1({
    brand: 'Audi',
    model: 'Q3',
    price: 35000,
});
// Выводим в лог переменную "carInstance1"
console.log('//-//-//-//-//-//-//-//-//-//-//-//-//-//-//');
console.log('"carInstance1" =>', carInstance1);
console.log('//-//-//-//-//-//-//-//-//-//-//-//-//-//-//');

// Выводим в лог объект-прототип указанной переменной экземпляра, с помощью метода "Object.getPrototypeOf()"
console.log(Object.getPrototypeOf(carInstance1));
console.log('--------------------------------------------');

// Проверяем "равны ли" между собой полученная с помощью "Object.getPrototypeOf()" ссылка и прототип класса "Car1" - "Car1.prototype".
console.log('"Object.getPrototypeOf(carInstance1) === Car1.prototype" =>', Object.getPrototypeOf(carInstance1) === Car1.prototype);
console.log('--------------------------------------------');
// Вызываем статический метод класса "logInfo"
Car1.logInfo(carInstance1);
console.log('********************************************');


// Для использования современного синтаксиса JS в устаревших версиях браузеров, есть возможность пользоваться специальными сервисами - так называемыми конвертерами или компиляторами языка JS. Которые производят конвертацию (трансформацию) современного кода в его "олд-скульный" вариант, который поддерживается соответствующими браузерами. Например, сервис "Babel" (https://babeljs.io/).


//Геттер - это синтаксис обращения к свойствам объекта основаный на использовании служебного слова "get". Сеттер - это синтаксис создания функции изменения свойств объекта основанных на использовании служебного слова "set".

// Пример использования геттеров и сетерров для написания кода методов класса.
class Car {
    static description = 'Класс описывающий автомобиль';

    static logInfo(carObj) {
        console.log('Car.logInfo -> carObj', carObj);
    }

    constructor({ brand, model, price } = {}) {
        this.brand = brand;
        this._model = model;
        this._price = price;
    }

    get price() {
        return this._price;
    }

    set price(newPrice) {
        this._price = newPrice;
    }

    get model() {
        return this._model;
    }

    set model(newModel) {
        this._model = newModel;
    }
}

const carInstance = new Car({
    brand: 'Audi',
    model: 'Q3',
    price: 35000,
});

console.log(carInstance.model);
carInstance.model = 'Q4';
console.log(carInstance.model);

console.log(carInstance.price);
carInstance.price = 50000;
console.log(carInstance.price);

console.log(carInstance);
console.log('--------------------------------------------');

// Пример использования геттеров и сетерров в объекте
const obj = {
    _a: 100,
    get a() {
        return this._a;
    },
    set a(x) {
        this._a = x;
    },
};
// Выводим в лог объект "obj"
console.log('Объект "obj" =>', obj);
console.log('--------------------------------------------');

// Используя геттер объекта - выводим в лог значение свойства "_a" объекта "obj"
console.log('Геттер - "obj.a" (до изменения значения) =>', obj.a);
console.log('--------------------------------------------');

// Используя сеттер объекта - задаем значение свойства "_a" объекту "obj".
obj.a = 555;

// Используя геттер объекта - выводим в лог измененное значение свойства "_a" объекта "obj"
console.log('Геттер - "obj.a" (после изменения значения) =>', obj.a);
console.log('********************************************');

// Геттеры и сеттеры используют в тех случаях, когда необходимо из-вне считывать и задавать значение какого либо свойства.
